#***66 check for prime strive A2Z basic maths
#striver problem
def isprime(self,N:int)->bool:
    counter=0
    for i in range(1,N+1):
        if N%i==0:
            counter+=1
    if counter==2:
        return True
    else:
        return False
        
#***alternate
class Solution:
    def isPrime (self, N):
        import math
        count=0
        for i in range(1,int(math.sqrt(N))+1):
            if N%i==0:
                count+=1
                if N//i!=i:
                    count+=1
        if count==2:
            return 1#returns 1 if prime
        return 0#returns 0 if not
                
        # code here


#***67 Armstrong Numbers
#User function Template for python3
class Solution:
    def armstrongNumber (ob, n)->str:
        summ=0
        ini=n
        while n!=0:
            summ+=(n%10)**3
            n=n//10
        if summ==ini:
            return "Yes"
        return "No"
        
#***68  Print all Divisors
#mymethod   ,did not run in GFG
class Solution:
    
    def sumOfDivisors(self, N):
        
        def findfactsum(self,n:int)->int:
            import math
            res=[]
            for i in range(1,int(math.sqrt(n))+1):
                if n%i==0:
                    res.append(i)
                    if n//i!=i:
                        res.append(n//i)
           
            return sum(res)
        res=0
        for i in range(1,N+1):
            res=res+findfactsum(self=9,n=i)
            
        return res
        
        
#69 strings easy Largest Element in Array
#my method 
def largest( arr, n):
    return max(arr)


#70 Second Largest GFG 3.1
#my method
class Solution:

	def print2largest(self,arr, n):
	    temp=max(arr)
	    while temp in arr:
	        arr.remove(temp)
	    if arr==[]:
	        return -1
	    return max(arr)
		# code h

#***striver optimized***
class Solution:

	def print2largest(self,arr, n):
        def secdmax(self,ar:list)->int:
            max = ar[0]
            secmax = -1
            for i,n in enumerate(ar):
                if n>max:
                    secmax=max
                    max=n
                elif n>secmax and n<max:
                    secmax=n

            return secmax
            
        k=secdmax(9,ar=arr)
        return k


#71*** A2Z 1752. Check if Array Is Sorted and Rotated
#mymethod success
class Solution:
    def check(self, nums: List[int]) -> bool:
        temp=list(nums)
        for i,n in enumerate(temp):
            nums.append(n)
            nums.pop(0)

            if nums==sorted(nums):
            
                return True
        return False
       
#71--mymenthod same problems GFG
class Solution:
    def arraySortedOrNot(self, arr, n):
        if arr==sorted(arr):
            return 1
        return 0
        


#***72 189. Rotate Array Left Rotate an array by one place and 	Left rotate an array by D places
#mymethod
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        temp=list(nums)
        k=k%len(temp)
        for i,n in enumerate(temp):
            if i==len(temp)-k:
                break
            nums.append(n)
            nums.pop(0)
            
		#striver optimized
#left rotate by one place
def leftrotatebyoneplace(self,n:list)->list:
    temp=n[0]
    # i=1
    for i in range(1,len(n)):
        n[i-1]=n[i]
    n[len(n)-1]=temp
    return n
    
#left rotate by n places
#***brute
def movebydplaces(self,n:list,k:int)->list:
    k=k%len(n)
    temp=n[:k]
    # j=0
    i=0
    for i in range(k,len(n)):
        n[i-k]=n[i]
        # j+=1
    # p=0
    print(i)
    for j in range(len(n)-k,len(n)):
        n[j]=temp[j-(len(n)-k)]
        # p+=1
    return n

#***optimal(super optimal)
def movebynplaces(self,n:list,k:int)->list:
    n[:k]=n[k-1::-1]
    n[k:]=n[:k-1:-1]
    n=n[::-1]
    return n



#73 linear search(Searching an element in a sorted array)GFG
class Solution:
    ##Complete this function
    def searchInSorted(self,arr, N, K):
        if K in arr:
            return 1
        return -1
	
	
#74--A-- Union of Two Sorted Arrays
#my method
class Solution:
    
    #Function to return a list containing the union of the two arrays.
    def findUnion(self,a,b,n,m):
        '''
        :param a: given sorted array a
        :param n: size of sorted array a
        :param b: given sorted array b
        :param m: size of sorted array b
        :return:  The union of both arrays as a list
        '''
        d=set()
        for i in b:
            if i not in d:
                d.add(i)
        for i in a:
            if i not in d:
                d.add(i)
        return sorted(list(d))
        # code here 



#74--A***--striver optimized 
class Solution:
    
    #Function to return a list containing the union of the two arrays.
    def findUnion(self,a,b,n,m):
        
        lis = []
        lf1 = 0
        lf2 = 0
    # print(a,b)
        while lf1 < len(a) and lf2 < len(b):
            if a[lf1] < b[lf2]:
                if len(lis) == 0:
                    lis.append(a[lf1])
                elif a[lf1]!=lis[-1]:
                    lis.append(a[lf1])
                lf1+=1
            else:
                if len(lis) == 0:
                    lis.append(b[lf2])
                elif b[lf2]!=lis[-1]:
                    lis.append(b[lf2])
                lf2 += 1

        while lf1 < len(a):
            if a[lf1]!=lis[-1]:
                lis.append(a[lf1])
            lf1 += 1
        while lf2 < len(b):
            if b[lf2]!=lis[-1]:
                lis.append(b[lf2])
            lf2 += 1
        return lis


#74---B---intersetion 

#74***bruteforce striver

def noeint(self,a,b,n,m):
    visit=[0]*len(b)
    count = 0
    for i,el in enumerate(a):
        for j,el2 in enumerate(b):
            if el==el2 and visit[j]==0:
                count+=1
                visit[j]=1
                break
            if el2>el:
                break
    return count
    
#***74---optimal striver codestudio
def findArrayIntersection(arr: list, n: int, brr: list, m: int):
    i=0
    j=0
    count=[]
    while i<n and j<m:
        if arr[i]==brr[j]:
            count.append(arr[i])
            i+=1
            j+=1
        elif arr[i]<brr[j]:
            i+=1
        elif arr[i]>brr[j]:
            j+=1
    return count

		
#75  268. Missing Number LT
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        check=set()
        for i in range(len(nums)+1):
            check.add(i)
        for i in list(check):
            if i not in nums:
                return (i)

#75 another different approach
def missingNumber(a : List[int], N : int) -> int:
    d={}
    for i in range(1,N+1):
        d[i]=0
    for i in a:
        d[i]=1
    for i in d.keys():
        if d[i]==0:
            return i


#***75 optimal striver 1 using summ
from typing import *

def missingNumber(a : List[int], N : int) -> int:
    # Write your code here.
    summ=(N*(N+1))//2
    return summ-sum(a)


#***75 optimal striver 2 using XOR
def missingNumber(a : List[int], N : int) -> int:
    # Write your code here.
    xor1=0
    xor2=0
    for i in range(1,N+1):
        xor1=xor1^i
    for j in a:
        xor2=xor2^j
        
    return xor1^xor2
    

#***75 missing number my approach
***--Find the Missing Number  GFG
#my method with least time complexity
#User function Template for python3

def missingNumber(A, N):
    A=sorted(A)
    med=(N+1)/2
    lf=0
    rt=len(A)-1
    while lf<=rt:
        if (A[lf]+A[rt])/2!=med:
            if (2*med-A[lf]) not in A:
                return int(2*med-A[lf])
            return int(2*med-A[rt])
        lf+=1
        rt-=1
            
     # Your code goes here
     

#76  485. Max Consecutive Ones LT
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        counter=0
        i=0
        maxx=0
        while i < len(nums):
            if nums[i]==1:
                while nums[i]!=0:
                    counter+=1
                    i+=1
                    if i==len(nums):
                        break
                maxx=max(maxx,counter)
                counter=0
            i+=1

        return maxx
	
#***76 striver optimal solution codestudio
from os import *
from sys import *
from collections import *
from math import *

from typing import List


def consecutiveOnes(arr: List[int]) -> int:
    maxx=0
    counter=0
    for i in arr:
        if i==1:
            counter+=1
        if i==0:
            maxx=max(counter,maxx)
            counter=0
    maxx=max(counter,maxx)
    return maxx



#***77 Subarray with given sum
#mycode
def longestSubarrayWithSumK(a: [int], k: int) -> int:

    # Write your code here

    lf=0
    rt=0
    l=[]
    while rt<len(a):
        if sum(a[lf:rt+1])==k:
            l.append(rt-lf+1)
            # lf+=1
            rt+=1

        if sum(a[lf:rt+1])>k:
            lf+=1
        
        if sum(a[lf:rt+1])<k:
            rt+=1
    
    return max(l)

#striver


     
78---74. Search a 2D Matrix LT 
#mymethod
class Solution(object):
    def searchMatrix(self, matrix, target):
        for i in range(len(matrix)):
            if target in matrix[i]:
                return True
        return False
                    
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
	
	
79***---Row with max 1s
#mymethod
class Solution:

	def rowWithMax1s(self,arr, n, m):
	    macs=0
	    res=-1
	    for i in range(len(arr)):
	       # macs=max(macs,arr[i].count(1))
	       # macs=0
	       if arr[i].count(1)>macs:
	           macs=arr[i].count(1)
	           res=i
	           
	    return res
	    
	    
80---


































 
